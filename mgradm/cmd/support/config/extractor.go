// SPDX-FileCopyrightText: 2024 SUSE LLC
//
// SPDX-License-Identifier: Apache-2.0

package config

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/uyuni-project/uyuni-tools/shared"
	"github.com/uyuni-project/uyuni-tools/shared/kubernetes"
	. "github.com/uyuni-project/uyuni-tools/shared/l10n"
	"github.com/uyuni-project/uyuni-tools/shared/podman"
	"github.com/uyuni-project/uyuni-tools/shared/types"
	"github.com/uyuni-project/uyuni-tools/shared/utils"
)

func extract(globalFlags *types.GlobalFlags, flags *configFlags, cmd *cobra.Command, args []string) error {
	cnx := shared.NewConnection(flags.Backend, podman.ServerContainerName, kubernetes.ServerFilter)
	supportConfigFiles, err := RunSupportConfig(cnx)
	if err != nil {
		return err
	}

	hostSupportConfigFiles, err := RunSupportConfigOnHost()
	if err != nil {
		return err
	}

	supportConfigFiles = append(supportConfigFiles, hostSupportConfigFiles...)

	// TODO Get cluster infos in case of kubernetes

	if err := CreateSupportConfigTarball(flags.Output, supportConfigFiles); err != nil {
		return err
	}

	return nil
}

/* CreateSupportConfigTarball will create a tarball in outputFolder with all the supportconfig
 * files generated by host and pods.
 */
func CreateSupportConfigTarball(outputFolder string, files []string) error {
	// Pack it all into a tarball
	log.Info().Msg(L("Preparing the tarball"))

	supportFileName := utils.GetSupportConfigFileSaveName()
	supportFilePath := path.Join(outputFolder, fmt.Sprintf("%s.tar.gz", supportFileName))

	tarball, err := utils.NewTarGz(supportFilePath)
	if err != nil {
		return err
	}

	for _, file := range files {
		if err := tarball.AddFile(file, path.Join(supportFileName, path.Base(file))); err != nil {
			return utils.Errorf(err, L("failed to add %s to tarball"), path.Base(file))
		}
	}
	tarball.Close()
	return nil
}

// RunSupportConfigOnHost will run supportconfig command on host machine.
func RunSupportConfigOnHost() ([]string, error) {
	var files []string
	extensions := []string{"", ".md5"}
	// Run supportconfig on the host if installed
	if _, err := exec.LookPath("supportconfig"); err == nil {
		out, err := utils.RunCmdOutput(zerolog.DebugLevel, "supportconfig")
		if err != nil {
			return []string{}, utils.Errorf(err, L("failed to run supportconfig on the host"))
		}
		tarballPath := utils.GetSupportConfigPath(string(out))

		// Look for the generated supportconfig file
		if tarballPath != "" && utils.FileExists(tarballPath) {
			for _, ext := range extensions {
				files = append(files, tarballPath+ext)
			}
		} else {
			return []string{}, errors.New(L("failed to find host supportconfig tarball from command output"))
		}
	} else {
		log.Warn().Msg(L("supportconfig is not available on the host, skipping it"))
	}
	return files, nil
}

// RunSupportConfig will run supportconfig command on given connection.
func RunSupportConfig(cnx *shared.Connection) ([]string, error) {
	var containerTarball string
	var files []string
	extensions := []string{"", ".md5"}
	containerName, err := cnx.GetPodName()
	if err != nil {
		return []string{}, err
	}

	// Copy the generated file locally
	tmpDir, err := os.MkdirTemp("", "mgradm-*")
	if err != nil {
		return []string{}, utils.Errorf(err, L("failed to create temporary directory"))
	}

	defer os.RemoveAll(tmpDir)
	// Run supportconfig in the container if it's running
	log.Info().Msgf(L("Running supportconfig in  %s"), containerName)
	out, err := cnx.Exec("supportconfig")
	if err != nil {
		return []string{}, errors.New(L("failed to run supportconfig"))
	} else {
		tarballPath := utils.GetSupportConfigPath(string(out))
		if tarballPath == "" {
			return []string{}, fmt.Errorf(L("failed to find container supportconfig tarball from command output"))
		}

		// TODO Get the error from copy
		for _, ext := range extensions {
			containerTarball = path.Join(tmpDir, containerName+"-supportconfig.txz"+ext)
			if err := cnx.Copy("server:"+tarballPath+ext, containerTarball, "", ""); err != nil {
				return []string{}, utils.Errorf(err, L("cannot copy tarball"))
			}
			files = append(files, containerTarball)

			// Remove the generated file in the container
			if _, err := cnx.Exec("rm", tarballPath+ext); err != nil {
				return []string{}, utils.Errorf(err, L("failed to remove %s file in the container"), tarballPath+ext)
			}
		}
	}
	return files, nil
}
